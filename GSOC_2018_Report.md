# Google Summer of Code 2018 Report


- Project name: **Enable DEVSIM to simulate solar cells**
- Student: **Noe Nieto** <nnnieto@noenieto.com>
- GSOC project : https://summerofcode.withgoogle.com/projects/#6392690430705664
- Repository for the Object-Oriented api: https://github.com/misaelnieto/devsim_gsoc_2018
- Example for the procedural api: https://github.com/misaelnieto/devsim/tree/master/examples/solar_cell
- Graphical application to browse devsim data: https://github.com/misaelnieto/tracey


## Introduction

This GSOC project is about enhancing [DEVSIM](https://devsim.org/) to be able to simulate solar cells. The Beer-Lambert algorithm was implemented and at the end I could connect the photogeneration of carriers into the continuity equations (see [devsim/models.py](devsim/models.py)), but for large values of photogeneration (i.e. > 1e20) the simulation fails with convergence failure. Altough the main goal of simulating a solar cell completely was not achieved, two implementations of the same algorithm were made, one within an Object-Oriented (OO) framework and the second one using the procedural style that came with devsim out of the box. A [graphical application](https://github.com/misaelnieto/tracey) to review the data generated by devsim was written, and in the future it could become really useful when the tool generates plots of the simulation data.

## Results

The code for the OO version is on the [https://github.com/misaelnieto/devsim_gsoc_2018](https://github.com/misaelnieto/devsim_gsoc_2018). This document is also part of it. Also there are no branches, so everything is in master. The procedural implementation is in my fork of the devsim source tree in https://github.com/misaelnieto/devsim/tree/master/examples/solar_cell

The main task to solve on this project was: "In order to simulate a solar cell it is necessary to simulate the propagation of light into the structure and calculate the resulting electrical current."

While studying the examples on devsim I reorganized the code a little bit and the result started to become an object-oriented API over the devsim core functions. So a lot of time was spent to propose an object oriented framework in which users could create their devices using modern ObjectOriented techniques.

The process to simulate a solar cell should be as follows:

1. Mesh creation.
2. Material configuration.
3. Doping profile.
4. Setup illumination conditions (i.e. AM0).
5. Setup Beer-Lambert model for photogeneration.
6. Compute initial solution
7. Solve the simulation with different conditions.
8. Compute/extract the figures of merit (Isc, Voc, IV Curve, etc.)
8. Export data (can be done in between the steps before)

Some of the implementation details will be explained in the following sections.

### Mesh creation

The mesh is one the most important aspects of the simulation.

Initially we thought that we'd need an external tool to define the mesh for the simulation (like gmesh), but after reading through the examples I found that there was already some example of simulations of 1D and 2D diodes using only the devsim functions. So I took this diodes as a base because the structure of a simple solar is very similar to the one of a junction diode.

As said before, simple meshes can be created by using devsim's native functions. But there's also the class [Mesh](devsim/mesh.py) that wraps the different devsim functions. You can use this class to add lines(1d and 2D), contacts and regions. A region is also a class that is used to associate a material with a region in an OO fashion.

Example:

```python
from devsim.mesh import Mesh

mesh = Mesh()
mesh.add_line(0.0, 0.1, 'top')
mesh.add_line(50, 0.01, 'mid')
mesh.add_line(100, 0.1, 'bottom')
```

By default mesh assumes the dimensions are microns, but you can use meters as well:


```python
mesh.add_line(50, 0.01, 'mid', scaling=1)
```

To create a 2D mesh the methods are slightly different.

```python
mesh.add_2d_line('x', 0.0,      1e-6, scale=1)
mesh.add_2d_line('y', 0,        1e-6, scale=1)
```

Altough devsim can do 3D meshes, these are still not supported on OO api.

### Regions and Material

Devsim needs to know the different parameters of a material. devsim has a collection of functions that help to configure parameters for materials using functions.

A region of the mesh can be related to a material so that the material properties are defined in this region only.

The OO api provides a [`Material`](devsim/materials/base.py) class that can register the material parameters automatically. It supports subclassing and customization of parameters at instantiation.

Only [Air](devsim/materials/air.py) and [Silicon](devsim/materials/silicon.py) are provided, but its relatively easy to add another material if you know the right parameters.

Examples:

```python
mesh.add_region(
    name='Cell Substrate',
    material=materials.Semiconductors.Silicon(),
    tag1='top', tag2='bottom'
)
```

Example with custom parameters for Silicon:

```python
mesh.add_region(
    name='Cell Substrate',
    material=materials.Silicon(taun=1e16, taup=1.44e-6),
    tag1='top', tag2='bottom'
)
```

The `Region` class is not explicitly used here; but internally the mesh objects deals with `Regions`.

When the time comes to solve the equations, the `Device` class (more below) takes into account this relationships to register the material properties using the devsim functions. This is done automatically, so you don't have to know all the properties of a material beforehand.


### Optical properties of materials.

In order to simulate a Solar Cell we need to simulate light interaction with a certain material. The refractive indexes of Air and Silicon are provided as [CSV files](devsim/data/README.md). The class responsible of loading this data ([RefractiveIndex](devsim/materials/refractive_index.py)) already knows how to load the correct refractive index based on the name of the material. Adding optical properties for other materials is possible without too much effort.


Using the refractive index is as easy as follows:

```python
> rfidx = RefractiveIndex()
...

> rfidx.alpha(wavelength=400)
5.2810000

> rfidx.refraction(850)
290.0
```

### Light sources

The class [AM0](devsim/materials/light_sources.py) provides the [AM0 (Air Mass 0)](devsim/data/README.md) spectrum from a trusted source. This class can be easily refactored to create other light sources like AM1.5 or even custom ones.


Both, the `AM0` and `RefractiveIndex` classes are used by the BeerLambertModel class to calculate photogeneration in a material/region.

### Device class

The Device class is one of the more important of all. It declares all the  [physical constants](devsim/__init__.py) (`devsim.PhysicalConstants`), and ambient conditions (`devsim.AmbientConditions`) such as the temperature. The properties of `AmbientConditions` are registered to devsim just before the initial solution, all other material parameters that depend on some of the ambient conditions (like tempertature) are resolved at run time.

An example of a device:

```python
from devsim.mesh import Mesh
from devsim.device import Device
mesh = Mesh()
# [... configuration of mesh ... ]
mesh.finalize()
scell = Device(mesh)
scell.initial_solution()
scell.solve(type='dc')
```
When the `initial_solution()` method is called, all the required parameters and constants are computed before solving the initial solution.

So when the `solve()` method is called, all the parameters, models, and data are already set up.

Another way to look at the `Device` class is that it is to Devsim as a Controller class is to a MVC framework.

### Beer-Lambert model

A basic implementation of The Beer-Lambert model can be found in the [BeerLambertModel](devsim/models.py) class. This model must be registered to a `Device`, for example:

```python
mdl = BeerLambertModel(scell, AM0(samples=25))
scell.setup_model(mdl)
```

In order to get an instance of `BeerLambertModel` you need to provide a device and the ilumination source. Then you need to register the model to the device. Internally, the device instance will call the photogeneration routine of the model when needed.

### Data export and visualization

Devsim supports the extraction of the mesh along with the resulting data into a data file in plain text. Data export is supported through the device instance like this:

```python
from devsim.device import Device

scell = Device()
# [ ... do stuff with the device .. ]
scell.export('scell_data_01.dat')
scell.export('scell_01.dat', format='devsim')
```

Internally, the device class uses the `ds.write_devices()` function and supports the format type through the `format` keyword. For `Device`, the default export format is `devsim_data`.

#### Tracey

Altough it was not required, a tool called [tracey](https://github.com/misaelnieto/tracey) was developed to inspect the data dumped by devsim. It's in a very early stage and it can only display the data in a data grid. In the future we can add support for graphs using the [matplotlib](https://matplotlib.org/) library.


# Conclusion and further work

What did get done?

- Two different approaches were developed to add solar cell simulation capabilities to devsim:
    - Working prototype of an Object oriented API, based on devsim, to simulate optical devices. This prototype was written to take advantage of best practices like setuptools packaging and unit tests (not 100% coverage).
    - Working prototype of the same simulation using the procedural approach of the core devsim package. As of now, all the devsim examples are written using the procedural approach, so people used to the procedural approach could get access to the Beer-Lambert model, Ilumination sources and refractive index without having to use the OO API.
- Altough in a very basic state, a GUI application to inspect data exported from devsim (Tracey).

What needs to be done?

- The photogeneration algorithm (Beer-Lambert) was implemented, but could not be completely integrated to the continuity equations of devsim.
- Calculate the short circuit current, open circuit voltage and the IV curve an the rest of the figures of merit.
- The photogeneration was not tested with devices with multiple regions.
- Implementation of other popular methods of photogeneration such as Transfer-Matrix Method or Raytracing.
- After the algorithm is stable, we need to compare the results of the devsim simulation with the results of other well-known simulators.

